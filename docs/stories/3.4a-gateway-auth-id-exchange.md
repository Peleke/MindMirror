# Story 3.4a: Gateway Authentication Enhancement (ID Exchange)

## Status
Draft

## Story
**As a** security engineer
**I want** gateway to parse JWT, query users_service for internal ID, cache result in Redis, and forward to mesh
**So that** clients cannot spoof `x-internal-id` (gateway becomes single auth validation point)

## Acceptance Criteria

1. **JWT parsing implemented:** Gateway parses `Authorization: Bearer [token]` header and extracts Supabase user ID (`sub` claim)
2. **users_service query:** Gateway queries `users_service` with Supabase ID to retrieve internal ID
3. **Redis caching:** Supabase ID → internal ID mappings cached in Redis (TTL: 1 hour)
4. **Cache fallback:** If Redis unavailable, gateway queries users_service directly (degraded performance, not failure)
5. **Header forwarding:** Gateway forwards `x-internal-id` header to mesh services (replaces client-provided value)
6. **Backward compatibility:** Gateway still accepts client `x-internal-id` during transition (dual-mode until Story 3.4b)
7. **Error handling:** Invalid JWT, missing user, or service errors return appropriate HTTP error codes (401, 404, 500)
8. **Logging:** All auth events logged (JWT validation, cache hits/misses, users_service queries, errors)
9. **Performance:** <50ms overhead for cached lookups, <200ms for cache miss (users_service query)

## Tasks / Subtasks

- [ ] **Set up Redis for gateway caching** (AC: 3, 4)
  - [ ] Verify Redis container running: `docker ps | grep redis`
  - [ ] Configure Redis connection in gateway environment variables:
    ```env
    REDIS_URL=redis://redis:6379
    REDIS_TTL=3600  # 1 hour cache TTL
    ```
  - [ ] Install Redis client in gateway: `npm install redis` (if not already installed)
  - [ ] Test Redis connectivity from gateway: `redis-cli ping` or via code

- [ ] **Implement JWT parsing in gateway** (AC: 1)
  - [ ] Install JWT library: `npm install jsonwebtoken @types/jsonwebtoken`
  - [ ] Create middleware or plugin to parse `Authorization` header:
    ```typescript
    import jwt from 'jsonwebtoken';

    function parseAuthToken(authHeader: string): { sub: string } | null {
      if (!authHeader || !authHeader.startsWith('Bearer ')) {
        return null;
      }

      const token = authHeader.substring(7); // Remove 'Bearer ' prefix

      try {
        // Note: For Supabase JWT, we need to validate signature with Supabase JWT secret
        const decoded = jwt.verify(token, process.env.SUPABASE_JWT_SECRET) as { sub: string };
        return { sub: decoded.sub };  // Supabase user ID
      } catch (error) {
        console.error('JWT validation failed:', error);
        return null;
      }
    }
    ```
  - [ ] Add `SUPABASE_JWT_SECRET` to environment variables (from Supabase Dashboard → Settings → API)
  - [ ] Test JWT parsing with valid and invalid tokens

- [ ] **Implement users_service query** (AC: 2)
  - [ ] Create GraphQL query to users_service:
    ```typescript
    const GET_INTERNAL_ID = `
      query GetInternalId($supabaseId: ID!) {
        userBySupabaseId(supabaseId: $supabaseId) {
          id_  # Internal ID
        }
      }
    `;

    async function getInternalId(supabaseId: string): Promise<string | null> {
      const response = await fetch(process.env.USERS_SERVICE_URL, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          query: GET_INTERNAL_ID,
          variables: { supabaseId },
        }),
      });

      const data = await response.json();
      return data?.data?.userBySupabaseId?.id_ || null;
    }
    ```
  - [ ] Add `USERS_SERVICE_URL` to environment variables (internal VPC URL from Story 3.3)
  - [ ] Test query with known Supabase ID

- [ ] **Implement Redis caching** (AC: 3, 4)
  - [ ] Create Redis cache layer:
    ```typescript
    import { createClient } from 'redis';

    const redisClient = createClient({
      url: process.env.REDIS_URL,
    });

    redisClient.on('error', (err) => console.error('Redis error:', err));
    await redisClient.connect();

    const CACHE_TTL = parseInt(process.env.REDIS_TTL || '3600', 10);  // 1 hour

    async function getInternalIdWithCache(supabaseId: string): Promise<string | null> {
      const cacheKey = `supabase_id:${supabaseId}`;

      try {
        // Try cache first
        const cached = await redisClient.get(cacheKey);
        if (cached) {
          console.log(`Cache hit for ${supabaseId}`);
          return cached;
        }
      } catch (error) {
        console.warn('Redis unavailable, falling back to direct query:', error);
      }

      // Cache miss or Redis unavailable - query users_service
      console.log(`Cache miss for ${supabaseId}, querying users_service`);
      const internalId = await getInternalId(supabaseId);

      if (internalId) {
        try {
          // Store in cache for next time
          await redisClient.setEx(cacheKey, CACHE_TTL, internalId);
        } catch (error) {
          console.warn('Failed to cache result:', error);
          // Continue without caching (degraded performance, not failure)
        }
      }

      return internalId;
    }
    ```
  - [ ] Test caching: First request (cache miss), second request (cache hit)
  - [ ] Test Redis failure: Stop Redis, verify gateway continues working (degraded)

- [ ] **Implement header forwarding logic** (AC: 5, 6)
  - [ ] Create middleware to intercept requests and add `x-internal-id`:
    ```typescript
    async function authMiddleware(req, res, next) {
      const authHeader = req.headers.authorization;

      // Parse JWT
      const parsed = parseAuthToken(authHeader);
      if (!parsed) {
        return res.status(401).json({ error: 'Invalid or missing authorization token' });
      }

      const supabaseId = parsed.sub;

      // Get internal ID (with caching)
      const internalId = await getInternalIdWithCache(supabaseId);
      if (!internalId) {
        return res.status(404).json({ error: 'User not found' });
      }

      // BACKWARD COMPATIBILITY: Check if client provided x-internal-id
      // Log mismatch for debugging (will remove client header in Story 3.4b)
      if (req.headers['x-internal-id'] && req.headers['x-internal-id'] !== internalId) {
        console.warn(`Client x-internal-id mismatch: client=${req.headers['x-internal-id']}, actual=${internalId}`);
      }

      // Forward gateway-validated internal ID to mesh (override client value)
      req.headers['x-internal-id'] = internalId;

      next();
    }
    ```
  - [ ] Apply middleware to all GraphQL requests
  - [ ] Test that mesh services receive correct `x-internal-id` from gateway

- [ ] **Implement error handling** (AC: 7)
  - [ ] Handle invalid JWT: Return 401 Unauthorized
  - [ ] Handle missing user: Return 404 Not Found
  - [ ] Handle users_service unavailable: Return 503 Service Unavailable
  - [ ] Handle Redis errors: Log warning, continue with direct query (don't fail request)
  - [ ] Add error response format:
    ```typescript
    {
      "error": "Invalid authorization token",
      "code": "INVALID_JWT",
      "details": "Token signature verification failed"
    }
    ```

- [ ] **Implement logging** (AC: 8)
  - [ ] Log JWT validation success: `console.log('JWT validated for user:', supabaseId)`
  - [ ] Log cache hits: `console.log('Cache hit for:', supabaseId)`
  - [ ] Log cache misses: `console.log('Cache miss for:', supabaseId)`
  - [ ] Log users_service queries: `console.log('Querying users_service for:', supabaseId)`
  - [ ] Log errors: `console.error('Auth error:', error)`
  - [ ] Consider structured logging (JSON format) for easier parsing in Cloud Logging

- [ ] **Test performance** (AC: 9)
  - [ ] Measure overhead with cache hit: Should be <50ms
  - [ ] Measure overhead with cache miss: Should be <200ms (users_service query)
  - [ ] Load test: 100 requests/second to gateway (verify Redis handles load)
  - [ ] Test Redis connection pooling (prevent connection exhaustion)

- [ ] **Test security** (Comprehensive manual testing)
  - [ ] **Test: Valid JWT with valid user** (should succeed)
  - [ ] **Test: Valid JWT with non-existent user** (should return 404)
  - [ ] **Test: Invalid JWT signature** (should return 401)
  - [ ] **Test: Expired JWT** (should return 401)
  - [ ] **Test: Missing Authorization header** (should return 401)
  - [ ] **Test: Malformed Authorization header** (should return 401)
  - [ ] **Test: Client attempts to spoof x-internal-id** (gateway should override, log warning)

## Dev Notes

### Relevant Source Tree
- **Gateway Code:** `mesh/gateway.config.ts`, `mesh/src/` (or wherever gateway logic lives)
- **Users Service:** Query endpoint for Supabase ID → internal ID mapping
- **Redis:** Existing Redis container (unused, perfect for this use case)
- **Environment Variables:** `REDIS_URL`, `SUPABASE_JWT_SECRET`, `USERS_SERVICE_URL`

### Key Technical Details

**JWT Structure (Supabase):**
```json
{
  "sub": "a1b2c3d4-e5f6-7890-abcd-ef1234567890",  // Supabase user ID
  "email": "user@example.com",
  "role": "authenticated",
  "iat": 1697000000,
  "exp": 1697086400  // Expiry (24 hours from iat)
}
```

**JWT Verification:**
- Supabase JWTs are signed with `SUPABASE_JWT_SECRET` (found in Supabase Dashboard → Settings → API)
- Use `jsonwebtoken` library to verify signature (prevents token tampering)
- If verification fails, reject request (401 Unauthorized)

**Redis Caching Strategy:**
- **Key format:** `supabase_id:{supabase-id}` (e.g., `supabase_id:a1b2c3d4-...`)
- **Value:** Internal ID (e.g., `123`)
- **TTL:** 1 hour (3600 seconds) - balance between performance and freshness
- **Eviction:** Automatic via TTL (no manual invalidation needed for alpha)

**Cache Invalidation (Future):**
- For alpha: No invalidation needed (1-hour TTL acceptable)
- For production: Invalidate cache when user is deleted/updated (Pub/Sub or webhook)

**users_service Dependency:**
- **CRITICAL:** If users_service is down, auth fails (entire system unusable)
- **Mitigation:** `min_instances = 1` for users_service (no cold starts)
- **Future:** Migrate users_service to Kubernetes for HA (3+ replicas)

**Backward Compatibility (Dual-Mode):**
- During transition, gateway accepts BOTH:
  1. Client-provided `x-internal-id` (legacy, INSECURE)
  2. Gateway-validated `x-internal-id` (new, SECURE)
- Gateway ALWAYS overrides client value with validated value
- Log mismatches to detect spoofing attempts or client bugs
- In Story 3.4b, remove client header requirement entirely

### Implementation Notes

**GraphQL Hive Gateway Integration:**
- Gateway uses GraphQL Hive for federation (not a custom Express server)
- Middleware needs to integrate with Hive's plugin system
- Likely use `useGenericAuth` plugin or custom plugin
- Reference: https://the-guild.dev/graphql/hive/docs/plugins

**Redis Connection Management:**
- Use connection pooling (Redis client handles this automatically)
- Handle Redis disconnects gracefully (fallback to direct query)
- Monitor Redis metrics: connection count, cache hit rate, latency

**users_service GraphQL Schema:**
- Ensure `userBySupabaseId` query exists in users_service schema
- If not, add it:
  ```graphql
  type Query {
    userBySupabaseId(supabaseId: ID!): User
  }
  ```
- Users service should have index on `supabase_id` column for fast lookups

### Security Considerations

**JWT Secret Protection:**
- `SUPABASE_JWT_SECRET` is HIGHLY SENSITIVE (can forge JWTs if leaked)
- Store in Secret Manager (not env files)
- Rotate periodically (Supabase Dashboard → Settings → API → Reset JWT Secret)

**Cache Poisoning:**
- Redis cache is single source of truth after first query
- If users_service returns wrong mapping, cache will persist for 1 hour
- **Mitigation:** Validate users_service responses, add cache invalidation if needed

**Timing Attacks:**
- JWT verification time might leak information about token validity
- Use constant-time comparison for JWT validation (library handles this)
- Don't leak detailed error messages to client (generic "Unauthorized")

**Rate Limiting (Future):**
- For production: Add rate limiting to prevent brute-force JWT attacks
- Use Redis for rate limit tracking (same instance)
- Not critical for alpha (minimal traffic)

### Testing

**Test file location:** Gateway integration tests + manual curl testing

**Test standards:**
- All auth scenarios covered (valid/invalid JWT, cache hit/miss, errors)
- Performance meets requirements (<50ms cache hit, <200ms cache miss)
- Security validated (spoofing prevented, errors handled correctly)

**Testing frameworks:**
- Jest for unit tests (JWT parsing, cache logic)
- Manual curl commands for integration testing
- Load testing with `ab` or `wrk` for performance validation

**Specific testing requirements:**

1. **Valid JWT Test:**
   ```bash
   # Get valid JWT from Supabase (log in as test user)
   TOKEN="eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9..."

   # Send GraphQL query with Authorization header
   curl -X POST https://gateway-prod-xyz.a.run.app/graphql \
     -H "Content-Type: application/json" \
     -H "Authorization: Bearer $TOKEN" \
     -d '{"query": "{ __typename }"}'

   # Expected: 200 OK with valid response
   # Check gateway logs: Should show JWT validated, cache miss/hit, internal ID forwarded
   ```

2. **Invalid JWT Test:**
   ```bash
   # Send request with invalid JWT
   curl -X POST https://gateway-prod-xyz.a.run.app/graphql \
     -H "Content-Type: application/json" \
     -H "Authorization: Bearer INVALID_TOKEN" \
     -d '{"query": "{ __typename }"}'

   # Expected: 401 Unauthorized
   # {"error": "Invalid or missing authorization token", "code": "INVALID_JWT"}
   ```

3. **Spoofing Attempt Test:**
   ```bash
   # Client attempts to send x-internal-id header (should be ignored/overridden)
   curl -X POST https://gateway-prod-xyz.a.run.app/graphql \
     -H "Content-Type: application/json" \
     -H "Authorization: Bearer $VALID_TOKEN" \
     -H "x-internal-id: 999" \
     -d '{"query": "{ user(id: \"test\") { id } }"}'

   # Expected: Gateway overrides with correct internal ID (not 999)
   # Check gateway logs: Should show warning about mismatch
   ```

4. **Cache Performance Test:**
   ```bash
   # First request (cache miss)
   time curl -X POST https://gateway-prod-xyz.a.run.app/graphql \
     -H "Authorization: Bearer $TOKEN" \
     -d '{"query": "{ __typename }"}'
   # Expected: ~150-200ms (users_service query)

   # Second request (cache hit)
   time curl -X POST https://gateway-prod-xyz.a.run.app/graphql \
     -H "Authorization: Bearer $TOKEN" \
     -d '{"query": "{ __typename }"}'
   # Expected: ~20-50ms (Redis cache)
   ```

5. **Redis Failure Test:**
   ```bash
   # Stop Redis container
   docker stop redis

   # Send request (should still work, just slower)
   curl -X POST https://gateway-prod-xyz.a.run.app/graphql \
     -H "Authorization: Bearer $TOKEN" \
     -d '{"query": "{ __typename }"}'

   # Expected: 200 OK (degraded performance, no caching)
   # Check logs: "Redis unavailable, falling back to direct query"

   # Restart Redis
   docker start redis
   ```

6. **Load Test:**
   ```bash
   # Use Apache Bench for load testing
   ab -n 1000 -c 10 -H "Authorization: Bearer $TOKEN" \
     -p graphql-query.json -T "application/json" \
     https://gateway-prod-xyz.a.run.app/graphql

   # Expected: >95% requests succeed, avg response time <100ms (with cache)
   ```

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-10-18 | v1.0 | New story: Gateway authentication enhancement with JWT parsing, users_service ID exchange, Redis caching | Alex (DevOps Agent) |

## Dev Agent Record

### Agent Model Used
_To be populated by dev agent_

### Debug Log References
_To be populated by dev agent_

### Completion Notes
_To be populated by dev agent_

### File List
_To be populated by dev agent_

## QA Results
_To be populated by QA agent_
